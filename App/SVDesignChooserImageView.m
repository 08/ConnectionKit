//
//  SVDesignChooserImageView.m
//  Sandvox
//
//  Created by Dan Wood on 11/16/09.
//  Copyright 2009 Karelia Software. All rights reserved.
//

#import "SVDesignChooserImageView.h"

const CGFloat kMyViewWidth = 108.0;				// 8 extra pixels for a border around the thumbnail
const CGFloat kMyViewHeight = 67.0;
const CGFloat kMyViewCornerRadius = 6.0;

@implementation SVDesignChooserImageView

- (void)drawRect:(NSRect)dirtyRect	// ADAPTED FROM CODE GENERATED BY OPACITY ... see commments for where things have changed
{
	[[NSGraphicsContext currentContext] saveGraphicsState];		// restored at bottom of function
	
	NSRect boundsOfThumb = NSMakeRect(4.0, 1.0, 100.0, 65.0);

	// Clip to a rounded rectangle
	NSBezierPath *clipPath = [NSBezierPath bezierPathWithRoundedRect:boundsOfThumb xRadius:kMyViewCornerRadius yRadius:kMyViewCornerRadius];
	[clipPath addClip];

	NSRect imageBounds = NSMakeRect(0.0, 0.0, kMyViewWidth, kMyViewHeight);
	NSRect bounds = [self bounds];
	NSAffineTransform *transform;
	CGContextRef context = [[NSGraphicsContext currentContext] graphicsPort];
	size_t bytesPerRow;
	void *bitmapData;
	CGColorSpaceRef space = CGColorSpaceCreateWithName(kCGColorSpaceGenericRGB);
	CGImageRef contextImage;
	NSRect effectBounds;
	unsigned char *pixels;
	CGFloat minX, maxX, minY, maxY;
	NSUInteger width, height;
	NSRect drawRect;
	NSBezierPath *path;
	NSGradient *gradient;
	CGFloat topHeight;
	CGFloat bottomHeight;
	NSColor *clearColor;
	CGContextRef maskContext;
	CGImageRef maskImage;
	CGFloat resolution;
	NSColor *color;
	resolution = [[self window] userSpaceScaleFactor] * 0.5 * (bounds.size.width / imageBounds.size.width + bounds.size.height / imageBounds.size.height);
	
	[[NSGraphicsContext currentContext] saveGraphicsState];
	transform = [NSAffineTransform transform];
	[transform scaleXBy:(bounds.size.width / imageBounds.size.width) yBy:(bounds.size.height / imageBounds.size.height)];
	[transform translateXBy:bounds.origin.x yBy:bounds.origin.y];
	[transform concat];
	
	// Setup for Glass Effect
	bytesPerRow = 4 * round(bounds.size.width);
	bitmapData = calloc(bytesPerRow * round(bounds.size.height), 8);
	context = CGBitmapContextCreate(bitmapData, round(bounds.size.width), round(bounds.size.height), 8, bytesPerRow, space, kCGImageAlphaPremultipliedLast);
	[NSGraphicsContext saveGraphicsState];
	[NSGraphicsContext setCurrentContext:[NSGraphicsContext graphicsContextWithGraphicsPort:context flipped:[[NSGraphicsContext currentContext] isFlipped]]];
	transform = [NSAffineTransform transform];
	[transform scaleXBy:(bounds.size.width / imageBounds.size.width) yBy:(bounds.size.height / imageBounds.size.height)];
	[transform concat];
	
	// Layer 1 -- HERE IS WHERE I CALL SUPER
	[super drawRect:dirtyRect];

	// Glass Effect
	bitmapData = CGBitmapContextGetData(context);
	pixels = (unsigned char *)bitmapData;
	width = round(bounds.size.width);
	height = round(bounds.size.height);
	minX = width;
	maxX = -1.0;
	minY = height;
	maxY = -1.0;
	for (NSInteger row = 0; row < height; row++) {
		for (NSInteger column = 0; column < width; column++) {
			if (pixels[4 * (width * row + column) + 3] > 0) {
				minX = MIN(minX, (CGFloat)column);
				maxX = MAX(maxX, (CGFloat)column);
				minY = MIN(minY, (CGFloat)(height - row));
				maxY = MAX(maxY, (CGFloat)(height - row));
			}
		}
	}
	contextImage = CGBitmapContextCreateImage(context);
	CGContextRelease(context);
	free(bitmapData);
	[NSGraphicsContext restoreGraphicsState];
	context = [[NSGraphicsContext currentContext] graphicsPort];
	CGContextDrawImage(context, NSRectToCGRect(imageBounds), contextImage);
	if ((minX <= maxX) && (minY <= maxY)) {
		[[NSGraphicsContext currentContext] saveGraphicsState];
		effectBounds = NSMakeRect(minX, minY - 1.0, maxX - minX + 1.0, maxY - minY + 1.0);
		bytesPerRow = round(effectBounds.size.width);
		maskContext = CGBitmapContextCreate(NULL, round(effectBounds.size.width), round(effectBounds.size.height), 8, bytesPerRow, NULL, kCGImageAlphaOnly);
		CGContextDrawImage(maskContext, CGRectMake(-effectBounds.origin.x, -effectBounds.origin.y, bounds.size.width, bounds.size.height), contextImage);
		maskImage = CGBitmapContextCreateImage(maskContext);
		transform = [NSAffineTransform transform];
		[transform scaleXBy:(imageBounds.size.width / bounds.size.width) yBy:(imageBounds.size.height / bounds.size.height)];
		[transform concat];
		CGContextClipToMask(context, NSRectToCGRect(effectBounds), maskImage);
		CGImageRelease(maskImage);
		CGContextRelease(maskContext);
		path = [NSBezierPath bezierPath];
		topHeight = effectBounds.size.height - (effectBounds.size.height * 0.7) * sqrt(1.0 - (0.5 * 0.5));
		bottomHeight = effectBounds.size.height * 0.7;
		drawRect = effectBounds;
		drawRect.origin.y -= drawRect.size.height * 0.7;
		drawRect.size.height *= 2.0 * 0.7;
		drawRect.size.width *= 1.0 / 0.5;
		drawRect.origin.x -= 0.5 * (drawRect.size.width - effectBounds.size.width);
		[path appendBezierPathWithOvalInRect:drawRect];
		[[NSGraphicsContext currentContext] saveGraphicsState];
		[path setWindingRule:NSEvenOddWindingRule];
		[path addClip];
		drawRect = effectBounds;
		drawRect.size.height = bottomHeight;
		color = [NSColor colorWithCalibratedRed:0.0 green:0.0 blue:0.0 alpha:0.1];	// was 0.5 bottom gradient down to darken
		clearColor = [color colorWithAlphaComponent:0.0];
		gradient = [[NSGradient alloc] initWithStartingColor:clearColor endingColor:color];
		[gradient drawFromPoint:NSMakePoint(drawRect.origin.x, NSMaxY(drawRect)) toPoint:drawRect.origin options:0];
		[[NSGraphicsContext currentContext] restoreGraphicsState];
		[path appendBezierPathWithRect:effectBounds];
		[path addClip];
		drawRect = effectBounds;
		drawRect.size.height = topHeight;
		drawRect.origin.y += effectBounds.size.height - topHeight;
		[gradient drawFromPoint:NSMakePoint(drawRect.origin.x, NSMaxY(drawRect)) toPoint:drawRect.origin options:0];
		[gradient release];
		color = [NSColor colorWithCalibratedRed:1.0 green:1.0 blue:1.0 alpha:0.3];	// top gloss
		[color setFill];
		NSRectFillUsingOperation(effectBounds, NSCompositeSourceOver);
		[[NSGraphicsContext currentContext] restoreGraphicsState];
	}
	CGImageRelease(contextImage);
	
	[[NSGraphicsContext currentContext] restoreGraphicsState];
	CGColorSpaceRelease(space);
		
	// Finally restore state and put a nice outline around the thing
	[[NSGraphicsContext currentContext] restoreGraphicsState];
	NSRect boundsEdges = NSInsetRect(boundsOfThumb, -0.5, -0.5);
	NSBezierPath *outlinePath = [NSBezierPath bezierPathWithRoundedRect:boundsEdges xRadius:kMyViewCornerRadius-0.5 yRadius:kMyViewCornerRadius-0.5];
	
	[[NSColor colorWithCalibratedRed:0.0 green:0.0 blue:0.0 alpha:1.0] set];	// Should contrast with background image somehow
	[outlinePath stroke];
	
	// Now for the stripes that show there are variations
	NSArray *colors = [NSArray arrayWithObjects:[NSColor redColor], [NSColor orangeColor], [NSColor yellowColor], [NSColor greenColor], [NSColor blueColor], [NSColor purpleColor], nil];
	int nColors = [colors count];
	float colorHeight = (65.0/nColors);
	float currentY = 1.0;						// starting Y coordinate
	
	NSUInteger i, count = [colors count];
	for ( i = 0; i < count; i++ )
	{
		NSColor *color = [colors objectAtIndex:i];
		[color set];
		NSRect leftRect  = NSMakeRect(0,   currentY, 2, colorHeight-1);
		NSRect rightRect = NSMakeRect(106, currentY, 2, colorHeight-1);
		[NSBezierPath fillRect:leftRect];
		[NSBezierPath fillRect:rightRect];
		currentY += colorHeight;
	}
	
}

@end
