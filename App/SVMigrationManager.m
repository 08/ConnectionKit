//
//  SVMigrationManager.m
//  Sandvox
//
//  Created by Mike on 14/02/2011.
//  Copyright 2011 Karelia Software. All rights reserved.
//

#import "SVMigrationManager.h"

#import "KTDocument.h"
#import "KT.h"

#import "KSExtensibleManagedObject.h"
#import "KSURLUtilities.h"


@implementation SVMigrationManager

- (id)initWithSourceModel:(NSManagedObjectModel *)sourceModel
               mediaModel:(NSManagedObjectModel *)mediaModel
         destinationModel:(NSManagedObjectModel *)destinationModel;
{
    OBPRECONDITION(mediaModel);
    
    if (self = [super initWithSourceModel:sourceModel destinationModel:destinationModel])
    {
        _mediaModel = [mediaModel retain];
    }
    
    return self;
}

- (id)initWithSourceModel:(NSManagedObjectModel *)sourceModel destinationModel:(NSManagedObjectModel *)destinationModel;
{
    return [self initWithSourceModel:sourceModel mediaModel:nil destinationModel:destinationModel];
}

- (BOOL)migrateDocumentFromURL:(NSURL *)sourceDocURL
              toDestinationURL:(NSURL *)dURL
                         error:(NSError **)outError;
{
    // Create context for accessing media during migration
    NSPersistentStoreCoordinator *coordinator = [[NSPersistentStoreCoordinator alloc]
                                                 initWithManagedObjectModel:[self sourceMediaModel]];
    
    NSURL *sMediaStoreURL = [sourceDocURL ks_URLByAppendingPathComponent:@"media.xml" isDirectory:NO];
    
    if (![coordinator addPersistentStoreWithType:NSXMLStoreType
                                   configuration:nil
                                             URL:sMediaStoreURL
                                         options:nil
                                           error:outError])
    {
        [coordinator release];
        return NO;
    }
    
    _mediaContext = [[NSManagedObjectContext alloc] init];
    [_mediaContext setPersistentStoreCoordinator:coordinator];
    [coordinator release];
    
    
    // Do the migration
    NSURL *modelURL = [NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@"Sandvox" ofType:@"cdm"]];
    NSMappingModel *mappingModel = [[NSMappingModel alloc] initWithContentsOfURL:modelURL];
    
    _docURL = sourceDocURL;
    _destinationURL = dURL;
    NSURL *sStoreURL = [KTDocument datastoreURLForDocumentURL:sourceDocURL type:kSVDocumentTypeName_1_5];
    NSURL *dStoreURL = [KTDocument datastoreURLForDocumentURL:dURL type:nil];
    
    NSError *error;
    BOOL result = [self migrateStoreFromURL:sStoreURL
                                       type:NSSQLiteStoreType
                                    options:nil
                           withMappingModel:mappingModel
                           toDestinationURL:dStoreURL
                            destinationType:NSBinaryStoreType
                         destinationOptions:nil
                                      error:&error];
    if (outError) *outError = error;
    
    _docURL = nil;
    _destinationURL = nil;
    [mappingModel release];
    [_mediaContext release];
    
    return result;
}

- (NSManagedObjectModel *)sourceMediaModel; { return _mediaModel; }

- (NSManagedObjectContext *)sourceMediaContext; { return _mediaContext; }

- (NSURL *)sourceURLOfMediaWithFilename:(NSString *)filename;
{
    NSURL *result = [[[_docURL ks_URLByAppendingPathComponent:@"Site" isDirectory:YES]
                      ks_URLByAppendingPathComponent:@"_Media" isDirectory:YES]
                     ks_URLByAppendingPathComponent:filename isDirectory:NO];
    return result;
}

- (NSURL *)destinationURLOfMediaWithFilename:(NSString *)filename;
{
    return [_destinationURL ks_URLByAppendingPathComponent:filename isDirectory:NO];
}

- (NSFetchRequest *)pagesFetchRequestWithPredicate:(NSString *)predicateString;
{
    // The default request generated by Core Data ignores sub-entites, meaning the home page doesn't get migrated. So, I wrote this custom method that builds a less picky predicate.
    
    NSFetchRequest *result = [[[NSFetchRequest alloc] init] autorelease];
    [result setEntity:[self sourceEntityForEntityMapping:[self currentEntityMapping]]];
    [result setPredicate:[NSPredicate predicateWithFormat:predicateString]];
    
    return result;
}

- (NSNumber *)isNil:(id)anObject; { return NSBOOL(anObject == nil); }
- (NSNumber *)isNotNil:(id)anObject; { return NSBOOL(anObject != nil); }
- (NSNumber *)boolValue:(id)anObject; { return NSBOOL([anObject boolValue]); }

- (NSDictionary *)extensiblePropertiesFromData:(NSData *)data;
{
    NSDictionary *result = [KSExtensibleManagedObject unarchiveExtensibleProperties:data];
    return result;
}

@end
